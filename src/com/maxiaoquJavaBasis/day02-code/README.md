## 类型转换、编码、运算符、表达式、方法

### Demo01DataType.java(数据类型转换:自动类型转换)
```shell
一、当数据类型不一样时，将会发生数据类型转换。

二、自动类型转换（隐式）
	1. 特点：代码不需要进行特殊处理，自动完成。
	2. 规则：数据范围从小到大。

三、强制类型转换（显式）
```

### Demo02DataType.java(数据类型转换:强制类型转换)
```shell
一、强制类型转换
  	1. 特点：代码需要进行特殊的格式处理，不能自动完成。
  	2. 格式：范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据;
  
二、注意事项：
  	1. 强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出。
  	2. byte/short/char这三种类型都可以发生数学运算，例如加法“+”.
  	3. byte/short/char这三种类型在运算的时候，都会被首先提升成为int类型，然后再计算。
  	4. boolean类型不能发生数据类型转换
```

### Demo03DataTypeChar.java(编码表)
```shell
一、数字和字符的对照关系表（编码表）：
    ASCII码表：American Standard Code for Information Interchange，美国信息交换标准代码。
    Unicode码表：万国码。也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是从128开始包含有更多字符。

二、举例（记住这三个就可以推算）：
    48 - '0'
    65 - 'A'
    97 - 'a'
```

### Demo04Operator.java(运算符和表达式：加、减、乘、除、取模)
```shell
一、运算符和表达式
    运算符：进行特定操作的符号。例如：+
    表达式：用运算符连起来的式子叫做表达式。例如：20 + 5。又例如：a + b

二、四则运算：
    加：+
    减：-
    乘：*
    除：/
    取模（取余数）：%

三、首先计算得到表达式的结果，然后再打印输出这个结果。
    复习一下小学一年级的除法公式：被除数 / 除数 = 商 ... 余数

四、对于一个整数的表达式来说，除法用的是整除，整数除以整数，结果仍然是整数。只看商，不看余数。
    只有对于整数的除法来说，取模运算符才有余数的意义。

五、注意事项：
	1. 一旦运算当中有不同类型的数据，那么结果将会是数据类型范围大的那种。
```

### Demo05Plus.java(“+”常见的三种用法)
```shell
一、四则运算当中的加号“+”有常见的三种用法：
    1. 对于数值来说，那就是加法。
    2. 对于字符char类型来说，在计算之前，char会被提升成为int，然后再计算。
       char类型字符，和int类型数字，之间的对照关系表：ASCII、Unicode
    3. 对于字符串String（首字母大写，并不是关键字）来说，加号代表字符串连接操作。
       任何数据类型和字符串进行连接的时候，结果都会变成字符串
```

### Demo06Operator.java(自增、自减运算符：++、--)
```shell
一、自增、自减运算符
    自增运算符：++
    自减运算符：--

二、基本含义：让一个变量涨一个数字1，或者让一个变量降一个数字1

三、使用格式：写在变量名称之前，或者写在变量名称之后。例如：++num，也可以num++

四、使用方式：
	1. 单独使用：不和其他任何操作混合，自己独立成为一个步骤。
	2. 混合使用：和其他操作混合，例如与赋值混合，或者与打印操作混合，等。

五、使用区别：
	1. 在单独使用的时候，前++和后++没有任何区别。也就是：++num;和num++;是完全一样的。
	2. 在混合的时候，有【重大区别】
		A. 如果是【前++】，那么变量【立刻马上+1】，然后拿着结果进行使用。	【先加后用】
		B. 如果是【后++】，那么首先使用变量本来的数值，【然后再让变量+1】。	【先用后加】
		
六、注意事项：
	1.只有变量才能使用自增、自减运算符。
    2.常量不可发生改变，所以不能用。
```

### Demo07Operator.java(赋值运算符：+=、-=、*=、/=、%=)
```shell
一、赋值运算符分为：
1、基本赋值运算符：
    就是一个等号“=”，代表将右侧的数据交给左侧的变量。
  	int a = 30;
  
2、复合赋值运算符：
  	+=		a += 3		相当于		a = a + 3
  	-=		b -= 4		相当于		b = b - 4
  	*=		c *= 5		相当于		c = c * 5
  	/=		d /= 6		相当于		d = d / 6
  	%=		e %= 7		相当于		e = e % 7
  
二、注意事项：
  	1. 只有变量才能使用赋值运算符，常量不能进行赋值。
  	2. 复合赋值运算符其中隐含了一个强制类型转换。
```

### Demo08Operator.java(比较运算符：>、<、>=、<=、==、!=)
```shell
一、比较运算符：
    大于：		>
    小于：		<
    大于等于：	>=
    小于等于：	<=
    相等：		==	【两个等号连写才是相等，一个等号代表的是赋值】
    不相等：	!=
  
二、注意事项：
  1. 比较运算符的结果一定是一个boolean值，成立就是true，不成立就是false
  2. 如果进行多次判断，不能连着写。
  数学当中的写法，例如：1 < x < 3
  程序当中【不允许】这种写法。
```

### Demo09Logic.java(逻辑运算符：&&、||、!)
```shell
一、逻辑运算符
    与（并且）	&&	全都是true，才是true；否则就是false
    或（或者）	||	至少一个是true，就是true；全都是false，才是false
    非（取反）	!	本来是true，变成false；本来是false，变成true
  
二、与“&&”，或“||”，具有短路效果：如果根据左边已经可以判断得到最终结果，那么右边的代码将不再执行，从而节省一定的性能。
  
三、注意事项：
    1. 逻辑运算符只能用于boolean值。
    2. 与、或需要左右各自有一个boolean值，但是取反只要有唯一的一个boolean值即可。
    3. 与、或两种运算符，如果有多个条件，可以连续写。
        两个条件：条件A && 条件B
        多个条件：条件A && 条件B && 条件C
  
四、TIPS：
    对于1 < x < 3的情况，应该拆成两个部分，然后使用与运算符连接起来：
    int x = 2;
    1 < x && x < 3
```

### Demo10Operator.java(*元运算符:三元运算符)
```shell
一、*元运算符
    一元运算符：只需要一个数据就可以进行操作的运算符。例如：取反!、自增++、自减--
    二元运算符：需要两个数据才可以进行操作的运算符。例如：加法+、赋值=
    三元运算符：需要三个数据才可以进行操作的运算符。
  
二、格式：
    数据类型 变量名称 = 条件判断 ? 表达式A : 表达式B;
  
三、流程：
    首先判断条件是否成立：
        如果成立为true，那么将表达式A的值赋值给左侧的变量；
        如果不成立为false，那么将表达式B的值赋值给左侧的变量；
        二者选其一。
  
四、注意事项：
    1. 必须同时保证表达式A和表达式B都符合左侧数据类型的要求。
    2. 三元运算符的结果必须被使用。
```

### Demo11Method.java(定义一个方法)
```shell
一、定义一个方法的格式：
    public static void 方法名称() {
        方法体
    }
  
二、格式
    方法名称：的命名规则和变量一样，使用小驼峰。
    方法体：也就是大括号当中可以包含任意条语句。
  
三、注意事项：
    1. 方法定义的先后顺序无所谓。
    2. 方法的定义不能产生嵌套包含关系。
    3. 方法定义好了之后，不会执行的。如果要想执行，一定要进行方法的【调用】。
  
四、如何调用方法，格式：
    方法名称();
```

### Demo12Notice.java(byte/short/char三种类型注意事项)
```shell
一、对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含地为我们补上一个(byte)(short)(char)。
  
二、注意
    1. 如果没有超过左侧的范围，编译器补上强转。
    2. 如果右侧超过了左侧范围，那么直接编译器报错。
```

### Demo13Notice.java(byte/short/char三种类型注意事项)
```shell
一、在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量， 那么编译器javac将会直接将若干个常量表达式计算得到结果。
  
二、short result = 5 + 8; // 等号右边全都是常量，没有任何变量参与运算
    编译之后，得到的.class字节码文件当中相当于【直接就是】：
    short result = 13;
    右侧的常量结果数值，没有超过左侧范围，所以正确。
    这称为“编译器的常量优化”。
  
二、注意：
    一旦表达式当中有变量参与，那么就不能进行这种优化了。
```